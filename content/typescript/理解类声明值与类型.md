---
title: "理解类声明值与类型"
date: 2025-09-04
draft: false
---

这段代码涉及到了 TypeScript 中类的构造函数、实例对象、类型等概念。让我们逐步解析每个部分，特别是 `console.log(C.a)` 报错的原因。

## 代码解析

```typescript
class C {
  a = "123";  // 类实例属性
}

let c: C = new C();  // 创建 C 类的一个实例

console.log(c);  // 输出: C { a: '123' }
console.log(C);  // 输出: [Function: C]，C 是构造函数
// console.log(C.a); // 报错：Property 'a' does not exist on type 'C'.
console.log(c.a);  // 输出: 123
console.log(c instanceof C);  // 输出: true
```

## 1. `console.log(C)` 输出的是构造函数

```typescript
console.log(C);  // 输出: [Function: C]
```

- `C` 是一个类，类的本质在 JavaScript 中是一个构造函数。`C` 本身是一个函数，用来创建 `C` 类的实例。
- 当你打印 `C` 时，输出的是类的构造函数。换句话说，`C` 是一个 **构造函数**，而不是一个对象实例或类的 **实例类型**。

## 2. `console.log(C.a)` 报错的原因

```typescript
// console.log(C.a); // 报错：Property 'a' does not exist on type 'C'.
```

- 在类定义 `class C { a = "123"; }` 中，`a` 是一个 **实例属性**，而不是 **类属性**。
- 也就是说，`a` 属于类的实例（例如通过 `new C()` 创建的 `c` 实例），并且在构造函数中初始化。
- 因此，`C` 作为构造函数并不直接包含 `a` 属性，`a` 只能通过类的 **实例对象** 访问。
- `console.log(C.a)` 会导致报错，因为 `a` 并不是 `C` 这个类本身的属性，而是实例的属性。

## 3. `console.log(c.a)` 正常输出 `123`

```typescript
console.log(c.a);  // 输出: 123
```

- `c` 是 `C` 类的一个实例对象，`c.a` 是访问 `C` 类实例上的属性 `a`。
- 由于 `a` 是实例属性，所以你可以通过 `c.a` 正常访问到值 `"123"`。

## 4. `console.log(c instanceof C)` 输出 `true`

```typescript
console.log(c instanceof C);  // 输出: true
```

- `instanceof` 运算符用于检查对象是否是某个类的实例。
- `c instanceof C` 返回 `true`，说明 `c` 确实是 `C` 类的实例。`instanceof` 会检查 `c` 是否是通过 `C` 构造函数创建的对象，或者是否位于 `C` 的原型链上。

## 总结

- **`C` 是构造函数**：类 `C` 在 TypeScript 和 JavaScript 中本质上是一个构造函数。通过 `new C()` 创建的对象才是 `C` 类的实例。
- **实例属性 vs. 类属性**：`a` 是类的实例属性，因此只能通过类的实例来访问；而 `C` 是类本身的构造函数，不包含实例属性 `a`。
- **`instanceof` 运算符**：`c instanceof C` 检查对象 `c` 是否是 `C` 类的实例，返回 `true` 表示 `c` 是通过 `C` 构造函数创建的。

所以，错误的根源是将 `C` 类本身误认为是实例对象，试图直接访问 `a`。而实际 `a` 是 `C` 类实例的属性，必须通过实例对象（如 `c.a`）来访问。
