> Lua 中的每个值都可以有一个 元表。 这个 元表 就是一个普通的 Lua 表， 它用于定义原始值在特定操作下的行为


举一个例子,类似于 c++的运算符重载,这里我们重载`+`

```Lua
foo = {a = 1}
print(foo.a)

smt = {
    __add = function(a,b)
        return a.a + b;
    end
}

setmetatable(foo, smt)

b = foo + 1
print(string.format("foo + 1 = %d", b))
```

## __index

> **`__index`:** 索引 `table[key]`。 当 `table` 不是表或是表 `table` 中不存在 `key` 这个键时，这个事件被触发。 此时，会读出 `table` 相应的元方法。
> 尽管名字取成这样， 这个事件的元方法其实可以是一个函数也可以是一张表。 如果它是一个函数，则以 `table` 和 `key` 作为参数调用它。 如果它是一张表，最终的结果就是以 `key` 取索引这张表的结果。 （这个索引过程是走常规的流程，而不是直接索引， 所以这次索引有可能引发另一次元方法。）

```lua
foo = {a = 1}
print(foo.a)

smt = {
    __index = function(table,key)
        return string.format("not found key : %s",key)
    end
}

setmetatable(foo, smt)
print(foo["mykey"])
print(foo[123])
```

## __newindex

> **`__newindex`:** 索引赋值 `table[key] = value` 。 和索引事件类似，它发生在 `table` 不是表或是表 `table` 中不存在 `key` 这个键的时候。 此时，会读出 `table` 相应的元方法。

> 同索引过程那样， 这个事件的元方法即可以是函数，也可以是一张表。 如果是一个函数， 则以 `table`、 `key`、以及 `value` 为参数传入。 如果是一张表， Lua 对这张表做索引赋值操作。 （这个索引过程是走常规的流程，而不是直接索引赋值， 所以这次索引赋值有可能引发另一次元方法。）

> 一旦有了 “newindex” 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 `rawset` 来做赋值。）

```lua
foo = {a = 1}
print(foo.a)

smt = {
    __newindex = function(table,key,value)
        --print(key,value)
        rawset(table,key,value)
    end
}

setmetatable(foo, smt)
foo["abc"] = 123
print(foo["abc"])
```

## 语法糖

> 这是 Lua 支持的一种语法糖。 像 v:name(args) 这个样子， 被解释成 v.name(v,args)， 这里的 v 只会被求值一次

> 冒号 语法可以用来定义 方法， 就是说，函数可以有一个隐式的形参 self。 因此，如下语句

```
function foo:new(a,b)
    -- ....
end

foo.new = function (self,a,b)
    -- ....
end
```

```lua
foo = {
    a = 1,
    add = function(table,value)
        table.a = table.a + value
    end
}

foo:add(1)
-- eq: foo.add(foo,1)
print(foo["a"])
```


这种语法糖实现了`c++`的`this`指针的类似功能,可以操作对象本身,而不需要传入对象本身.

## 面向对象

`matetable` 非常类似于javascript 的`prototype`，可以用来实现面向对象

代码1实现: 

- 类的构造函数
- 类的方法

```lua
local fooClass = {}

function fooClass:new(name) {
    local t = { name = name}
    local t_smt = {
        __add = function(a,b) ... end
        -- 添加各种能力

        -- 添加基础属
        "default_name" = "bar" 
    }
    t_smt["__index"] = t_smt
    setmetatable(t,t_smt)
    return t
}

```

代码2实现: 类的继承 原理: `__index` 可以指向一个表,当访问的key不存在时,会去`__index`指向的表中查找

```lua
function newObject(value)
    return setmetatable({}, {__index = value})
end

function createClass(...)
    local c = {} -- a new class instance
    setmetatable(c, {__index = ...})
    c.__index = c
    function c:new (o)
        o = o or {}
        setmetatable(o, c)
        return o
    end
    return c
end

local animal = createClass()
function animal:new(name)
    local o = {name = name}
    self.__index = self
    setmetatable(o, self)
    return o
end

function animal:printName()
    print(self.name)
end

local dog = animal:new("dog")
dog:printName()
```
