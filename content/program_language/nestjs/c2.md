---
title: "IOC 控制反转 DI依赖注入"
date: 2025-11-09
draft: false
toc: true
tags: [""]
categories: [""]
---

在学习nestjs 之前需要先了解其设计模式

## IOC

Inversion of Control字面意思是控制反转，具体定义是高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

## DI

依赖注入（Dependency Injection）其实和IoC是同根生，这两个原本就是一个东西，只不过由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”。 类A依赖类B的常规表现是在A中使用B的instance。

### 案例未使用控制反转和依赖注入之前的代码

```typescript
class A {
    name: string
    constructor(name: string) {
        this.name = name
    }
}
 
 
class B {
    age:number
    entity:A // 属性 entity A 类型
    constructor (age:number) {
        this.age = age;
        this.entity = new A('小满')
    }
}
 
const c = new B(18)
 
c.entity.name
```

我们可以看到，B 中代码的实现是需要依赖 A 的，两者的代码耦合度非常高。当两者之间的业务逻辑复杂程度增加的情况下，维护成本与代码可读性都会随着增加，并且很难再多引入额外的模块进行功能拓展。

### 为了解决这个问题可以使用IOC容器

```typescript
class A {
    name: string
    constructor(name: string) {
        this.name = name
    }
}
 
 
class C {
    name: string
    constructor(name: string) {
        this.name = name
    }
}
// 中间容器
//中间件用于解耦
class Container {
    modeuls: any
    constructor() {
        this.modeuls = {}
    }

    // 提供 对象 ,放入容器
    provide(key: string, modeuls: any) {
        this.modeuls[key] = modeuls
    }
    get(key) {
        return this.modeuls[key]
    }
}
 
const mo = new Container()
mo.provide('a', new A('小满1')) // 放入对象
mo.provide('c', new C('小满2'))
 
class B {
    a: any
    c: any
    // 从容器里面得到 想要的对象
    constructor(container: Container) {
        this.a = container.get('a')
        this.c = container.get('c')
    }
}
 
new B(mo)
```

其实就是写了一个中间件，来**收集依赖**，主要是为了解耦，减少维护成本

