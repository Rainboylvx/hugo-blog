---
title: "设计思想"
date: 2025-09-24
draft: true
toc: true
tags: [""]
categories: [""]
---


太棒了！这是一个非常经典且有价值的场景。为 Codeforces (或其他 competitive programming 平台) 打造一个高效的 Neovim 工作流，可以极大地提升你的解题速度和体验。

我们将围绕一系列**精心设计的 Bash 脚本**和 Neovim 配置，构建一个无缝的“编码-编译-测试-调试”循环。

### 核心理念

你的工作目录将围绕**一个问题一个文件夹**的模式展开。例如：

```
/home/user/codeforces/
├── 1800A/
│   ├── main.cpp
│   ├── input.txt
│   ├── answer.txt
│   └── .vscode/
│       └── launch.json  (用于 DAP 调试)
├── 1800B/
│   └── ...
└── templates/
    ├── default.cpp
    ├── graph.cpp
    └── math.cpp
```

每个文件夹都是一个独立的工作区，包含代码、输入、标准输出和调试配置。

---

### 第一步：设置模板和初始化脚本

这是所有工作的起点。我们需要一个脚本来快速创建上述的目录结构。

#### 1. 代码模板 (`~/codeforces/templates/default.cpp`)

首先，创建一个或多个你常用的代码模板。这是一个基础模板示例：

```cpp
// ~/codeforces/templates/default.cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
// ... 其他常用头文件

// Fast I/O
void fast_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
}

// 主解题函数
void solve() {
    // 在这里写你的代码
}

int main() {
    fast_io();
    int t = 1;
    std::cin >> t; // 如果是多组测试用例
    while (t--) {
        solve();
    }
    return 0;
}
```

#### 2. 初始化脚本 (`cf-new.sh`)

在你的 `PATH` 环境变量能找到的地方（例如 `~/.local/bin/`）创建一个名为 `cf-new.sh` 的脚本。

```bash
#!/bin/bash

# cf-new.sh - 创建一个新的 Codeforces 问题目录

# 检查是否提供了问题名称
if [ -z "$1" ]; then
    echo "Usage: $0 <problem_name> [template_name]"
    exit 1
fi

PROBLEM_NAME=$1
TEMPLATE_NAME=${2:-default} # 如果没有提供模板名，则默认为 default
BASE_DIR="/home/user/codeforces" # !! 修改为你的 Codeforces 根目录
TEMPLATE_PATH="$BASE_DIR/templates/${TEMPLATE_NAME}.cpp"
PROBLEM_DIR="$BASE_DIR/$PROBLEM_NAME"

# 检查模板是否存在
if [ ! -f "$TEMPLATE_PATH" ]; then
    echo "Error: Template '${TEMPLATE_NAME}.cpp' not found at $TEMPLATE_PATH"
    exit 1
fi

# 创建问题目录
mkdir -p "$PROBLEM_DIR"
cd "$PROBLEM_DIR" || exit

# 复制模板文件并创建输入/输出文件
cp "$TEMPLATE_PATH" "main.cpp"
touch "input.txt"
touch "answer.txt"

echo "Successfully created problem directory: $PROBLEM_DIR"
echo "Files created: main.cpp, input.txt, answer.txt"

# (可选) 自动用 nvim 打开
nvim main.cpp
```

**如何使用它？**
打开终端，运行：
`chmod +x ~/.local/bin/cf-new.sh` (只需运行一次，使其可执行)

现在，要开始解决 1800A 题，只需：
`cf-new.sh 1800A`

如果你想用图论模板：
`cf-new.sh 1800C graph`

---

### 第二步：核心工作流脚本 (编译、运行、对比)

在你的 `PATH` 下创建以下两个脚本。

#### 1. 编译和运行脚本 (`cf-run.sh`)

这个脚本是你的主力。它会编译、运行、计时，并将输出重定向。

```bash
#!/bin/bash

# cf-run.sh - 编译并运行 C++ 文件，使用 input.txt 作为输入

FILENAME="main.cpp"
EXE_NAME="main_debug"
INPUT_FILE="input.txt"
OUTPUT_FILE="my_output.txt"

# 编译代码
# -g: 生成调试信息
# -std=c++17: 使用 C++17 标准
# -Wall: 显示所有警告
# -fsanitize=address,undefined: (可选但强烈推荐) 检查内存和未定义行为
g++ -g -std=c++17 -Wall -fsanitize=address,undefined "$FILENAME" -o "$EXE_NAME"

# 检查编译是否成功
if [ $? -ne 0 ]; then
    echo "--- COMPILE ERROR ---"
    exit 1
fi

echo "--- COMPILE SUCCESS ---"
echo "--- RUNNING ---"

# 运行并计时
/usr/bin/time -f "--- Execution Time: %es ---" ./"$EXE_NAME" < "$INPUT_FILE" > "$OUTPUT_FILE"

echo "--- FINISHED ---"
echo "Output is in $OUTPUT_FILE"
```
**`chmod +x ~/.local/bin/cf-run.sh`**

#### 2. 对比结果脚本 (`cf-diff.sh`)

这个脚本用于对比你的输出和标准答案。

```bash
#!/bin/bash

# cf-diff.sh - 对比 my_output.txt 和 answer.txt

MY_OUT="my_output.txt"
ANS_OUT="answer.txt"

if [ ! -f "$MY_OUT" ] || [ ! -f "$ANS_OUT" ]; then
    echo "Error: Make sure both $MY_OUT and $ANS_OUT exist."
    exit 1
fi

# 使用 diff 命令，--color 选项可以在终端中高亮差异
diff --color=always -y --suppress-common-lines "$MY_OUT" "$ANS_OUT"

if [ $? -eq 0 ]; then
    echo "--- All Correct! ---"
fi
```
**`chmod +x ~/.local/bin/cf-diff.sh`**

---

### 第三步：Neovim 集成 (快捷键和插件)

现在我们将这些脚本和功能无缝集成到 Neovim 中。

#### 1. 集成终端 (`toggleterm.nvim`)

一个好的浮动终端对于查看编译结果和输出至关重要。

```lua
-- lua/plugins/toggleterm.lua
return {
  'akinsho/toggleterm.nvim',
  version = "*",
  opts = {
    direction = 'float',
    float_opts = {
      border = 'curved',
    },
  },
}
```

#### 2. 定义核心快捷键

在你的 Neovim 配置中（例如 `init.lua` 或 `lua/keymaps.lua`），添加：

```lua
-- 创建一个函数来打开浮动终端并执行命令
function RunInToggleTerm(cmd)
  -- 寻找一个名为 'floatterm' 的终端，如果没有就创建一个
  local term = require('toggleterm.terminal').get('floatterm')
  if not term then
      term = require('toggleterm.terminal').Terminal:new({ id = 'floatterm', hidden = true })
  end
  
  -- 打开终端窗口并发送命令
  require('toggleterm').toggle(term:id())
  vim.cmd('startinsert')
  vim.api.nvim_chan_send(term.job_id, cmd .. '\n')
end

-- 编译 & 运行
vim.keymap.set('n', '<leader>r', function() RunInToggleTerm('cf-run.sh') end, { desc = "CF: Compile & Run" })

-- 对比结果
vim.keymap.set('n', '<leader>d', function() RunInToggleTerm('cf-diff.sh') end, { desc = "CF: Diff Output" })

-- 切换到终端（用于手动操作）
vim.keymap.set('n', '<leader>tt', '<cmd>ToggleTerm<cr>', { desc = "Toggle Terminal" })
```

#### 3. DAP 快速调试 (`launch.json`)

为了让 `nvim-dap` 在这个工作流中发挥作用，我们需要一个能自动读取 `input.txt` 的 `launch.json` 文件。

你可以把这个文件放在你的 `templates` 目录下，让 `cf-new.sh` 自动创建 `.vscode` 目录并复制它。

**`~/codeforces/templates/launch.json`**
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "(gdb) Launch",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/main_debug",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      // 核心部分：将标准输入重定向到 input.txt
      "pipeTransport": {
        "pipeCwd": "${workspaceFolder}",
        "pipeProgram": "bash",
        "pipeArgs": ["-c"],
        "debuggerPath": "/usr/bin/gdb"
      },
      "sourceFileMap": {
        "/build/glibc-SzIz7B/glibc-2.31": "/usr/src/glibc"
      },
      "preLaunchTask": "C/C++: g++ build active file"
    }
  ]
}
```
**修改 `cf-new.sh`**:
在 `mkdir` 和 `cp` 之间加入：
```bash
# ...
mkdir -p "$PROBLEM_DIR/.vscode"
cd "$PROBLEM_DIR" || exit

cp "$BASE_DIR/templates/launch.json" ".vscode/launch.json"
# ...
```

#### 4. Competitive Programming 代码片段

使用 `LuaSnip`，你可以定义一些非常有用的片段。在你的 `luasnip` 配置文件中添加：

```lua
-- 示例：快速 for 循环
s("fori", fmt(
  "for (int {1} = 0; {1} < {2}; ++{1}) {{\n\t{3}\n}}",
  { i(1, "i"), i(2, "n"), i(0) }
)),

-- 示例：读取一个 vector
s("readv", fmt(
  "std::vector<{1}> {2}({3});\nfor (int i = 0; i < {3}; ++i) {{\n\tstd::cin >> {2}[i];\n}}",
  { i(1, "int"), i(2, "v"), i(3, "n") }
)),
```

---

### 最终工作流程演示

现在，你拥有了一个完整的“驾驶舱”。解决一道题的流程如下：

1.  **启动**: `cf-new.sh 1800A`。Nvim 自动打开 `main.cpp`。
2.  **编码**:
    *   你开始编写 `solve()` 函数。
    *   需要一个 for 循环？输入 `fori` 然后按 `<Tab>`。
    *   需要读取一个 vector？输入 `readv` 然后按 `<Tab>`。
3.  **准备测试**:
    *   从题目页面复制示例输入，粘贴到 `input.txt` 文件中。
    *   复制示例输出，粘贴到 `answer.txt` 文件中。
4.  **快速测试**:
    *   回到 `main.cpp`，按下 `<leader>r`。
    *   一个浮动终端弹出，显示编译和运行结果。
5.  **验证结果**:
    *   按下 `<leader>d`。
    *   浮动终端会显示你的输出和标准答案的差异。如果完全正确，会提示 "All Correct!"。
6.  **调试**:
    *   如果结果错误，你可以在代码中设置断点（默认 `<F9>`）。
    *   按下 `<F5>` 启动 DAP 调试会话。DAP 会自动使用 `input.txt` 作为输入，你可以在断点处检查变量，单步执行，就像在 IDE 中一样。
7.  **重复**: 修复 bug 后，回到第 4 步，循环往复，直到通过所有示例。

这个工作流将 Neovim 的速度、终端的强大功能和 IDE 的调试能力完美地结合在一起，专为 competitive programming 的高强度、快节奏环境而设计。